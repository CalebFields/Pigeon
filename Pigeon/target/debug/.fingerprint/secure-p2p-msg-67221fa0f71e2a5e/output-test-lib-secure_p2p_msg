{"$message_type":"diagnostic","message":"cannot find derive macro `NetworkBehaviour` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":212,"byte_end":228,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":true,"text":[{"text":"#[derive(NetworkBehaviour)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`NetworkBehaviour` is imported here, but it is only a trait, without a derive macro","code":null,"level":"note","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":86,"byte_end":109,"line_start":3,"line_end":3,"column_start":5,"column_end":28,"is_primary":true,"text":[{"text":"    swarm::NetworkBehaviour,","highlight_start":5,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find derive macro `NetworkBehaviour` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:8:10\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(NetworkBehaviour)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `NetworkBehaviour` is imported here, but it is only a trait, without a derive macro\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    swarm::NetworkBehaviour,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `behaviour` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":234,"byte_end":243,"line_start":9,"line_end":9,"column_start":3,"column_end":12,"is_primary":true,"text":[{"text":"#[behaviour(out_event = \"MessageProtocolEvent\")]","highlight_start":3,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find attribute `behaviour` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:9:3\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[behaviour(out_event = \"MessageProtocolEvent\")]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `protocol`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\network\\ping.rs","byte_start":269,"byte_end":277,"line_start":11,"line_end":11,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    swarm: Swarm<protocol::MessageProtocol>,","highlight_start":18,"highlight_end":26}],"label":"use of unresolved module or unlinked crate `protocol`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `protocol`, use `cargo add protocol` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider importing this module","code":null,"level":"help","spans":[{"file_name":"src\\network\\ping.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::{crypto, storage};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::network::protocol;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of unresolved module or unlinked crate `protocol`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\ping.rs:11:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    swarm: Swarm<protocol::MessageProtocol>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `protocol`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `protocol`, use `cargo add protocol` to add it to your `Cargo.toml`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::network::protocol;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `crypto` and `storage`","code":{"code":"unused_imports","explanation":null},"level":"error","spans":[{"file_name":"src\\network\\ping.rs","byte_start":12,"byte_end":18,"line_start":1,"line_end":1,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"use crate::{crypto, storage};","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\ping.rs","byte_start":20,"byte_end":27,"line_start":1,"line_end":1,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"use crate::{crypto, storage};","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`-D unused-imports` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(unused_imports)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\network\\ping.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::{crypto, storage};","highlight_start":1,"highlight_end":30},{"text":"use libp2p::{","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused imports: `crypto` and `storage`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\ping.rs:1:13\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::{crypto, storage};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `-D unused-imports` implied by `-D warnings`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(unused_imports)]`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::crypto`","code":{"code":"unused_imports","explanation":null},"level":"error","spans":[{"file_name":"src\\storage\\contacts.rs","byte_start":4,"byte_end":17,"line_start":1,"line_end":1,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use crate::crypto;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\storage\\contacts.rs","byte_start":0,"byte_end":20,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::crypto;","highlight_start":1,"highlight_end":19},{"text":"use serde::{Deserialize, Serialize};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `crate::crypto`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\storage\\contacts.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::crypto;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sled::IVec`","code":{"code":"unused_imports","explanation":null},"level":"error","spans":[{"file_name":"src\\storage\\contacts.rs","byte_start":62,"byte_end":72,"line_start":3,"line_end":3,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"use sled::IVec;","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\storage\\contacts.rs","byte_start":58,"byte_end":75,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use sled::IVec;","highlight_start":1,"highlight_end":16},{"text":"use std::net::SocketAddr;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `sled::IVec`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\storage\\contacts.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sled::IVec;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::crypto`","code":{"code":"unused_imports","explanation":null},"level":"error","spans":[{"file_name":"src\\storage\\queue.rs","byte_start":4,"byte_end":17,"line_start":1,"line_end":1,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use crate::crypto;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\storage\\queue.rs","byte_start":0,"byte_end":20,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::crypto;","highlight_start":1,"highlight_end":19},{"text":"use serde::{Deserialize, Serialize};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `crate::crypto`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\storage\\queue.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::crypto;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `crypto` and `storage`","code":{"code":"unused_imports","explanation":null},"level":"error","spans":[{"file_name":"src\\ui\\cli.rs","byte_start":12,"byte_end":19,"line_start":1,"line_end":1,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"use crate::{storage, crypto};","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\ui\\cli.rs","byte_start":21,"byte_end":27,"line_start":1,"line_end":1,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"use crate::{storage, crypto};","highlight_start":22,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\ui\\cli.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::{storage, crypto};","highlight_start":1,"highlight_end":30},{"text":"use clap::{Parser, Subcommand};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused imports: `crypto` and `storage`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\ui\\cli.rs:1:13\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::{storage, crypto};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated struct `libp2p::libp2p_swarm::SwarmBuilder`: Use the new `libp2p::SwarmBuilder` instead of `libp2p::swarm::SwarmBuilder` or create a `Swarm` directly via `Swarm::new`.","code":{"code":"deprecated","explanation":null},"level":"error","spans":[{"file_name":"src\\network\\ping.rs","byte_start":73,"byte_end":85,"line_start":4,"line_end":4,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"    swarm::{SwarmBuilder, SwarmEvent},","highlight_start":13,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`-D deprecated` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(deprecated)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: use of deprecated struct `libp2p::libp2p_swarm::SwarmBuilder`: Use the new `libp2p::SwarmBuilder` instead of `libp2p::swarm::SwarmBuilder` or create a `Swarm` directly via `Swarm::new`.\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\ping.rs:4:13\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    swarm::{SwarmBuilder, SwarmEvent},\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `-D deprecated` implied by `-D warnings`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(deprecated)]`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated struct `libp2p::libp2p_swarm::SwarmBuilder`: Use the new `libp2p::SwarmBuilder` instead of `libp2p::swarm::SwarmBuilder` or create a `Swarm` directly via `Swarm::new`.","code":{"code":"deprecated","explanation":null},"level":"error","spans":[{"file_name":"src\\network\\ping.rs","byte_start":989,"byte_end":1001,"line_start":27,"line_end":27,"column_start":21,"column_end":33,"is_primary":true,"text":[{"text":"        let swarm = SwarmBuilder::new(transport, behaviour, peer_id)","highlight_start":21,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: use of deprecated struct `libp2p::libp2p_swarm::SwarmBuilder`: Use the new `libp2p::SwarmBuilder` instead of `libp2p::swarm::SwarmBuilder` or create a `Swarm` directly via `Swarm::new`.\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\ping.rs:27:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let swarm = SwarmBuilder::new(transport, behaviour, peer_id)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime parameters or bounds on method `read_request` do not match the trait declaration","code":{"code":"E0195","explanation":"The lifetime parameters of the method do not match the trait declaration.\n\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `'b` for `bar()` implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":1369,"byte_end":1372,"line_start":53,"line_end":53,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":20,"highlight_end":23}],"label":"lifetimes do not match method in trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0195]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime parameters or bounds on method `read_request` do not match the trait declaration\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:53:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::fut\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mlifetimes do not match method in trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime parameters or bounds on method `write_request` do not match the trait declaration","code":{"code":"E0195","explanation":"The lifetime parameters of the method do not match the trait declaration.\n\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `'b` for `bar()` implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2028,"byte_end":2031,"line_start":68,"line_end":68,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":21,"highlight_end":24}],"label":"lifetimes do not match method in trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0195]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime parameters or bounds on method `write_request` do not match the trait declaration\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:68:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin:\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mlifetimes do not match method in trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime parameters or bounds on method `read_response` do not match the trait declaration","code":{"code":"E0195","explanation":"The lifetime parameters of the method do not match the trait declaration.\n\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `'b` for `bar()` implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2633,"byte_end":2636,"line_start":82,"line_end":82,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":21,"highlight_end":24}],"label":"lifetimes do not match method in trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0195]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime parameters or bounds on method `read_response` do not match the trait declaration\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:82:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::fu\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mlifetimes do not match method in trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime parameters or bounds on method `write_response` do not match the trait declaration","code":{"code":"E0195","explanation":"The lifetime parameters of the method do not match the trait declaration.\n\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `'b` for `bar()` implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":3294,"byte_end":3297,"line_start":97,"line_end":97,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":22,"highlight_end":25}],"label":"lifetimes do not match method in trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0195]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime parameters or bounds on method `write_response` do not match the trait declaration\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:97:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m97\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::p\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mlifetimes do not match method in trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `pub_key_bytes`","code":{"code":"unused_variables","explanation":null},"level":"error","spans":[{"file_name":"src\\ui\\cli.rs","byte_start":1496,"byte_end":1509,"line_start":64,"line_end":64,"column_start":21,"column_end":34,"is_primary":true,"text":[{"text":"                let pub_key_bytes = hex::decode(&public_key)","highlight_start":21,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`-D unused-variables` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(unused_variables)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\ui\\cli.rs","byte_start":1496,"byte_end":1509,"line_start":64,"line_end":64,"column_start":21,"column_end":34,"is_primary":true,"text":[{"text":"                let pub_key_bytes = hex::decode(&public_key)","highlight_start":21,"highlight_end":34}],"label":null,"suggested_replacement":"_pub_key_bytes","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused variable: `pub_key_bytes`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\ui\\cli.rs:64:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let pub_key_bytes = hex::decode(&public_key)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: if this is intentional, prefix it with an underscore: `_pub_key_bytes`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `-D unused-variables` implied by `-D warnings`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(unused_variables)]`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\crypto.rs","byte_start":820,"byte_end":834,"line_start":31,"line_end":31,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"    let mut h = Blake2bMac::new_from_slice(local_secret).expect(\"Valid key size\");","highlight_start":29,"highlight_end":43}],"label":"multiple `new_from_slice` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `blake2::digest::Mac` for the type `T`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `blake2::digest::KeyInit` for the type `blake2::Blake2bMac<OutSize>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"src\\crypto.rs","byte_start":808,"byte_end":820,"line_start":31,"line_end":31,"column_start":17,"column_end":29,"is_primary":true,"text":[{"text":"    let mut h = Blake2bMac::new_from_slice(local_secret).expect(\"Valid key size\");","highlight_start":17,"highlight_end":29}],"label":null,"suggested_replacement":"<blake2::Blake2bMac<_> as blake2::digest::KeyInit>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\crypto.rs","byte_start":808,"byte_end":820,"line_start":31,"line_end":31,"column_start":17,"column_end":29,"is_primary":true,"text":[{"text":"    let mut h = Blake2bMac::new_from_slice(local_secret).expect(\"Valid key size\");","highlight_start":17,"highlight_end":29}],"label":null,"suggested_replacement":"<blake2::Blake2bMac<_> as blake2::digest::Mac>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: multiple applicable items in scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\crypto.rs:31:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut h = Blake2bMac::new_from_slice(local_secret).expect(\"Valid key size\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `new_from_slice` found\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `blake2::digest::Mac` for the type `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `blake2::digest::KeyInit` for the type `blake2::Blake2bMac<OutSize>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m    let mut h = \u001b[0m\u001b[0m\u001b[38;5;9mBlake2bMac::\u001b[0m\u001b[0mnew_from_slice(local_secret).expect(\"Valid key size\");\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m    let mut h = \u001b[0m\u001b[0m\u001b[38;5;10m<blake2::Blake2bMac<_> as blake2::digest::KeyInit>::\u001b[0m\u001b[0mnew_from_slice(local_secret).expect(\"Valid key size\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m    let mut h = \u001b[0m\u001b[0m\u001b[38;5;9mBlake2bMac::\u001b[0m\u001b[0mnew_from_slice(local_secret).expect(\"Valid key size\");\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m    let mut h = \u001b[0m\u001b[0m\u001b[38;5;10m<blake2::Blake2bMac<_> as blake2::digest::Mac>::\u001b[0m\u001b[0mnew_from_slice(local_secret).expect(\"Valid key size\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `new` found for struct `libp2p::libp2p_swarm::SwarmBuilder` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\network\\ping.rs","byte_start":1003,"byte_end":1006,"line_start":27,"line_end":27,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"        let swarm = SwarmBuilder::new(transport, behaviour, peer_id)","highlight_start":35,"highlight_end":38}],"label":"function or associated item not found in `SwarmBuilder<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `libp2p::libp2p_swarm::SwarmBuilder<_>` consider using one of the following associated functions:\nlibp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::with_executor\nlibp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::with_tokio_executor\nlibp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::without_executor","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-swarm-0.43.7\\src\\lib.rs","byte_start":59099,"byte_end":59309,"line_start":1522,"line_end":1527,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"    pub fn with_executor(","highlight_start":5,"highlight_end":1},{"text":"        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,","highlight_start":1,"highlight_end":1},{"text":"        behaviour: TBehaviour,","highlight_start":1,"highlight_end":1},{"text":"        local_peer_id: PeerId,","highlight_start":1,"highlight_end":1},{"text":"        executor: impl Executor + Send + 'static,","highlight_start":1,"highlight_end":1},{"text":"    ) -> Self {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-swarm-0.43.7\\src\\lib.rs","byte_start":60414,"byte_end":60580,"line_start":1565,"line_end":1569,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"    pub fn with_tokio_executor(","highlight_start":5,"highlight_end":32},{"text":"        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,","highlight_start":1,"highlight_end":63},{"text":"        behaviour: TBehaviour,","highlight_start":1,"highlight_end":31},{"text":"        local_peer_id: PeerId,","highlight_start":1,"highlight_end":31},{"text":"    ) -> Self {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-swarm-0.43.7\\src\\lib.rs","byte_start":61800,"byte_end":61963,"line_start":1604,"line_end":1608,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"    pub fn without_executor(","highlight_start":5,"highlight_end":29},{"text":"        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,","highlight_start":1,"highlight_end":63},{"text":"        behaviour: TBehaviour,","highlight_start":1,"highlight_end":31},{"text":"        local_peer_id: PeerId,","highlight_start":1,"highlight_end":31},{"text":"    ) -> Self {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no function or associated item named `new` found for struct `libp2p::libp2p_swarm::SwarmBuilder` in the current scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\ping.rs:27:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m27\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let swarm = SwarmBuilder::new(transport, behaviour, peer_id)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item not found in `SwarmBuilder<_>`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `libp2p::libp2p_swarm::SwarmBuilder<_>` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      libp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::with_executor\u001b[0m\n\u001b[0m      libp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::with_tokio_executor\u001b[0m\n\u001b[0m      libp2p::libp2p_swarm::SwarmBuilder::<TBehaviour>::without_executor\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-swarm-0.43.7\\src\\lib.rs:1522:5\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn with_executor(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        behaviour: TBehaviour,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        local_peer_id: PeerId,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1526\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        executor: impl Executor + Send + 'static,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> Self {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_____________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1565\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn with_tokio_executor(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1566\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1567\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        behaviour: TBehaviour,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1568\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        local_peer_id: PeerId,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1569\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> Self {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_____________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1604\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn without_executor(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1605\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        transport: transport::Boxed<(PeerId, StreamMuxerBox)>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1606\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        behaviour: TBehaviour,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1607\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        local_peer_id: PeerId,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1608\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> Self {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_____________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`network::protocol::FileExchangeCodec` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":460,"byte_end":477,"line_start":16,"line_end":16,"column_start":39,"column_end":56,"is_primary":true,"text":[{"text":"        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);","highlight_start":39,"highlight_end":56}],"label":"`network::protocol::FileExchangeCodec` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":445,"byte_end":459,"line_start":16,"line_end":16,"column_start":24,"column_end":38,"is_primary":false,"text":[{"text":"        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);","highlight_start":24,"highlight_end":38}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::iter::Iterator` is not implemented for `network::protocol::FileExchangeCodec`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `network::protocol::FileExchangeCodec` to implement `std::iter::IntoIterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `libp2p::libp2p_request_response::Behaviour::<TCodec>::new`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs","byte_start":12825,"byte_end":12828,"line_start":351,"line_end":351,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new<I>(protocols: I, cfg: Config) -> Self","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs","byte_start":12888,"byte_end":12944,"line_start":353,"line_end":353,"column_start":12,"column_end":68,"is_primary":true,"text":[{"text":"        I: IntoIterator<Item = (TCodec::Protocol, ProtocolSupport)>,","highlight_start":12,"highlight_end":68}],"label":"required by this bound in `Behaviour::<TCodec>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `network::protocol::FileExchangeCodec` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:16:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`network::protocol::FileExchangeCodec` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the trait `std::iter::Iterator` is not implemented for `network::protocol::FileExchangeCodec`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: required for `network::protocol::FileExchangeCodec` to implement `std::iter::IntoIterator`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `libp2p::libp2p_request_response::Behaviour::<TCodec>::new`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs:353:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m351\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new<I>(protocols: I, cfg: Config) -> Self\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m353\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: IntoIterator<Item = (TCodec::Protocol, ProtocolSupport)>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Behaviour::<TCodec>::new`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":479,"byte_end":500,"line_start":16,"line_end":16,"column_start":58,"column_end":79,"is_primary":true,"text":[{"text":"        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);","highlight_start":58,"highlight_end":79}],"label":"expected `Config`, found `ProtocolSupport`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":445,"byte_end":459,"line_start":16,"line_end":16,"column_start":24,"column_end":38,"is_primary":false,"text":[{"text":"        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);","highlight_start":24,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs","byte_start":12825,"byte_end":12828,"line_start":351,"line_end":351,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new<I>(protocols: I, cfg: Config) -> Self","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:16:58\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Config`, found `ProtocolSupport`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs:351:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m351\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new<I>(protocols: I, cfg: Config) -> Self\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `network::protocol::FileExchangeCodec: std::default::Default` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":445,"byte_end":501,"line_start":16,"line_end":16,"column_start":24,"column_end":80,"is_primary":true,"text":[{"text":"        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);","highlight_start":24,"highlight_end":80}],"label":"the trait `std::default::Default` is not implemented for `network::protocol::FileExchangeCodec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `libp2p::libp2p_request_response::Behaviour::<TCodec>::new`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs","byte_start":12825,"byte_end":12828,"line_start":351,"line_end":351,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new<I>(protocols: I, cfg: Config) -> Self","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs","byte_start":12659,"byte_end":12666,"line_start":348,"line_end":348,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"    TCodec: Codec + Default + Clone + Send + 'static,","highlight_start":21,"highlight_end":28}],"label":"required by this bound in `Behaviour::<TCodec>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `network::protocol::FileExchangeCodec` with `#[derive(Default)]`","code":null,"level":"help","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":941,"byte_end":941,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct FileExchangeCodec;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Default)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `network::protocol::FileExchangeCodec: std::default::Default` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:16:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let protocol = Behaviour::new(FileExchangeCodec, ProtocolSupport::Full);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `std::default::Default` is not implemented for `network::protocol::FileExchangeCodec`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `libp2p::libp2p_request_response::Behaviour::<TCodec>::new`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Caleb Fields\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libp2p-request-response-0.25.3\\src\\lib.rs:348:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m348\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TCodec: Codec + Default + Clone + Send + 'static,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Behaviour::<TCodec>::new`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m351\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new<I>(protocols: I, cfg: Config) -> Self\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider annotating `network::protocol::FileExchangeCodec` with `#[derive(Default)]`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ #[derive(Default)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m36\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mpub struct FileExchangeCodec;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":1408,"byte_end":1409,"line_start":53,"line_end":53,"column_start":59,"column_end":60,"is_primary":false,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":59,"highlight_end":60}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":1373,"byte_end":1374,"line_start":53,"line_end":53,"column_start":24,"column_end":25,"is_primary":false,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":24,"highlight_end":25}],"label":"let's call the lifetime of this reference `'2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":1592,"byte_end":1997,"line_start":57,"line_end":65,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Box::pin(async move {","highlight_start":9,"highlight_end":30},{"text":"            let mut len_bytes = [0u8; 4];","highlight_start":1,"highlight_end":42},{"text":"            io.read_exact(&mut len_bytes).await?;","highlight_start":1,"highlight_end":50},{"text":"            let len = u32::from_be_bytes(len_bytes) as usize;","highlight_start":1,"highlight_end":62},{"text":"            let mut buf = vec![0u8; len];","highlight_start":1,"highlight_end":42},{"text":"            io.read_exact(&mut buf).await?;","highlight_start":1,"highlight_end":44},{"text":"            bincode::deserialize(&buf)","highlight_start":1,"highlight_end":39},{"text":"                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))","highlight_start":1,"highlight_end":86},{"text":"        })","highlight_start":1,"highlight_end":11}],"label":"method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider introducing a named lifetime parameter and update trait if needed","code":null,"level":"help","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":1374,"byte_end":1374,"line_start":53,"line_end":53,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":1409,"byte_end":1409,"line_start":53,"line_end":53,"column_start":60,"column_end":60,"is_primary":true,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":60,"highlight_end":60}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":1370,"byte_end":1370,"line_start":53,"line_end":53,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"'a, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:57:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::f\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'2`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::pin(async move {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let mut len_bytes = [0u8; 4];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            io.read_exact(&mut len_bytes).await?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let len = u32::from_be_bytes(len_bytes) as usize;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter and update trait if needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    fn read_request<\u001b[0m\u001b[0m\u001b[38;5;10m'a, \u001b[0m\u001b[0mT>(&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut self, _: &Self::Protocol, io: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Request>> + Send + '_>>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2067,"byte_end":2068,"line_start":68,"line_end":68,"column_start":60,"column_end":61,"is_primary":false,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":60,"highlight_end":61}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2032,"byte_end":2033,"line_start":68,"line_end":68,"column_start":25,"column_end":26,"is_primary":false,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":25,"highlight_end":26}],"label":"let's call the lifetime of this reference `'2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2261,"byte_end":2602,"line_start":72,"line_end":79,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Box::pin(async move {","highlight_start":9,"highlight_end":30},{"text":"            let bytes = bincode::serialize(&req)","highlight_start":1,"highlight_end":49},{"text":"                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;","highlight_start":1,"highlight_end":88},{"text":"            let len = bytes.len() as u32;","highlight_start":1,"highlight_end":42},{"text":"            io.write_all(&len.to_be_bytes()).await?;","highlight_start":1,"highlight_end":53},{"text":"            io.write_all(&bytes).await?;","highlight_start":1,"highlight_end":41},{"text":"            io.flush().await","highlight_start":1,"highlight_end":29},{"text":"        })","highlight_start":1,"highlight_end":11}],"label":"method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider introducing a named lifetime parameter and update trait if needed","code":null,"level":"help","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2033,"byte_end":2033,"line_start":68,"line_end":68,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2068,"byte_end":2068,"line_start":68,"line_end":68,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2029,"byte_end":2029,"line_start":68,"line_end":68,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"'a, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:72:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> std::pi\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'2`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::pin(async move {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let bytes = bincode::serialize(&req)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let len = bytes.len() as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            io.flush().await\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter and update trait if needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    fn write_request<\u001b[0m\u001b[0m\u001b[38;5;10m'a, \u001b[0m\u001b[0mT>(&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut self, _: &Self::Protocol, io: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut T, req: Self::Request) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2672,"byte_end":2673,"line_start":82,"line_end":82,"column_start":60,"column_end":61,"is_primary":false,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":60,"highlight_end":61}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2637,"byte_end":2638,"line_start":82,"line_end":82,"column_start":25,"column_end":26,"is_primary":false,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":25,"highlight_end":26}],"label":"let's call the lifetime of this reference `'2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2857,"byte_end":3262,"line_start":86,"line_end":94,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Box::pin(async move {","highlight_start":9,"highlight_end":30},{"text":"            let mut len_bytes = [0u8; 4];","highlight_start":1,"highlight_end":42},{"text":"            io.read_exact(&mut len_bytes).await?;","highlight_start":1,"highlight_end":50},{"text":"            let len = u32::from_be_bytes(len_bytes) as usize;","highlight_start":1,"highlight_end":62},{"text":"            let mut buf = vec![0u8; len];","highlight_start":1,"highlight_end":42},{"text":"            io.read_exact(&mut buf).await?;","highlight_start":1,"highlight_end":44},{"text":"            bincode::deserialize(&buf)","highlight_start":1,"highlight_end":39},{"text":"                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))","highlight_start":1,"highlight_end":86},{"text":"        })","highlight_start":1,"highlight_end":11}],"label":"method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider introducing a named lifetime parameter and update trait if needed","code":null,"level":"help","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":2638,"byte_end":2638,"line_start":82,"line_end":82,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2673,"byte_end":2673,"line_start":82,"line_end":82,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":2634,"byte_end":2634,"line_start":82,"line_end":82,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"'a, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:86:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> std::pin::Pin<Box<dyn std::\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'2`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::pin(async move {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let mut len_bytes = [0u8; 4];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            io.read_exact(&mut len_bytes).await?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let len = u32::from_be_bytes(len_bytes) as usize;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter and update trait if needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    fn read_response<\u001b[0m\u001b[0m\u001b[38;5;10m'a, \u001b[0m\u001b[0mT>(&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut self, _: &Self::Protocol, io: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut T) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<Self::Response>> + Send + '_>>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":3333,"byte_end":3334,"line_start":97,"line_end":97,"column_start":61,"column_end":62,"is_primary":false,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":61,"highlight_end":62}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":3298,"byte_end":3299,"line_start":97,"line_end":97,"column_start":26,"column_end":27,"is_primary":false,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":26,"highlight_end":27}],"label":"let's call the lifetime of this reference `'2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":3529,"byte_end":3871,"line_start":101,"line_end":108,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Box::pin(async move {","highlight_start":9,"highlight_end":30},{"text":"            let bytes = bincode::serialize(&resp)","highlight_start":1,"highlight_end":50},{"text":"                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;","highlight_start":1,"highlight_end":88},{"text":"            let len = bytes.len() as u32;","highlight_start":1,"highlight_end":42},{"text":"            io.write_all(&len.to_be_bytes()).await?;","highlight_start":1,"highlight_end":53},{"text":"            io.write_all(&bytes).await?;","highlight_start":1,"highlight_end":41},{"text":"            io.flush().await","highlight_start":1,"highlight_end":29},{"text":"        })","highlight_start":1,"highlight_end":11}],"label":"method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider introducing a named lifetime parameter and update trait if needed","code":null,"level":"help","spans":[{"file_name":"src\\network\\protocol.rs","byte_start":3299,"byte_end":3299,"line_start":97,"line_end":97,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":3334,"byte_end":3334,"line_start":97,"line_end":97,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\network\\protocol.rs","byte_start":3295,"byte_end":3295,"line_start":97,"line_end":97,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"'a, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime may not live long enough\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network\\protocol.rs:101:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, resp: Self::Response) -> std\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'2`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::pin(async move {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let bytes = bincode::serialize(&resp)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let len = bytes.len() as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            io.flush().await\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter and update trait if needed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    fn write_response<\u001b[0m\u001b[0m\u001b[38;5;10m'a, \u001b[0m\u001b[0mT>(&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut self, _: &Self::Protocol, io: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut T, resp: Self::Response) -> std::pin::Pin<Box<dyn std::future::Future<Output = std::io::Result<()>> + Send + '_>>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 24 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 24 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0034, E0195, E0277, E0308, E0433, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0034, E0195, E0277, E0308, E0433, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0034`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0034`.\u001b[0m\n"}
